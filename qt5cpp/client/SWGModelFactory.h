/**
 * GraphHopper Directions API
 * With the GraphHopper Directions API you get reliable and fast web services for routing and more with world wide coverage. We offer A-to-B routing via the Routing API optionally with turn instructions and elevation data as well as route optimization with various constraints like time window and capacity restrictions. Also it is possible to get all distances between all locations with our fast Matrix API. 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#ifndef ModelFactory_H_
#define ModelFactory_H_


#include "SWGActivity.h"
#include "SWGAddress.h"
#include "SWGAlgorithm.h"
#include "SWGBreak.h"
#include "SWGCostMatrix.h"
#include "SWGGHError.h"
#include "SWGGHError_hints.h"
#include "SWGGHGeocodingLocation.h"
#include "SWGGHGeocodingPoint.h"
#include "SWGGHGeocodingResponse.h"
#include "SWGGHIsochroneResponse.h"
#include "SWGGHIsochroneResponsePolygon.h"
#include "SWGGHIsochroneResponsePolygon_geometry.h"
#include "SWGGHIsochroneResponsePolygon_properties.h"
#include "SWGGHMatrixRequest.h"
#include "SWGGHMatrixResponse.h"
#include "SWGGHResponseCoordinates.h"
#include "SWGGHResponseCoordinatesArray.h"
#include "SWGGHResponseInfo.h"
#include "SWGGHResponseInstruction.h"
#include "SWGGHResponseInstructions.h"
#include "SWGGHRouteResponse.h"
#include "SWGGHRouteResponsePath.h"
#include "SWGJobId.h"
#include "SWGObjective.h"
#include "SWGRelation.h"
#include "SWGRequest.h"
#include "SWGResponse.h"
#include "SWGRoute.h"
#include "SWGService.h"
#include "SWGShipment.h"
#include "SWGSolution.h"
#include "SWGSolution_unassigned.h"
#include "SWGStop.h"
#include "SWGTimeWindow.h"
#include "SWGVehicle.h"
#include "SWGVehicleType.h"

namespace Swagger {
  inline void* create(QString type) {
    if(QString("SWGActivity").compare(type) == 0) {
      return new SWGActivity();
    }
    if(QString("SWGAddress").compare(type) == 0) {
      return new SWGAddress();
    }
    if(QString("SWGAlgorithm").compare(type) == 0) {
      return new SWGAlgorithm();
    }
    if(QString("SWGBreak").compare(type) == 0) {
      return new SWGBreak();
    }
    if(QString("SWGCostMatrix").compare(type) == 0) {
      return new SWGCostMatrix();
    }
    if(QString("SWGGHError").compare(type) == 0) {
      return new SWGGHError();
    }
    if(QString("SWGGHError_hints").compare(type) == 0) {
      return new SWGGHError_hints();
    }
    if(QString("SWGGHGeocodingLocation").compare(type) == 0) {
      return new SWGGHGeocodingLocation();
    }
    if(QString("SWGGHGeocodingPoint").compare(type) == 0) {
      return new SWGGHGeocodingPoint();
    }
    if(QString("SWGGHGeocodingResponse").compare(type) == 0) {
      return new SWGGHGeocodingResponse();
    }
    if(QString("SWGGHIsochroneResponse").compare(type) == 0) {
      return new SWGGHIsochroneResponse();
    }
    if(QString("SWGGHIsochroneResponsePolygon").compare(type) == 0) {
      return new SWGGHIsochroneResponsePolygon();
    }
    if(QString("SWGGHIsochroneResponsePolygon_geometry").compare(type) == 0) {
      return new SWGGHIsochroneResponsePolygon_geometry();
    }
    if(QString("SWGGHIsochroneResponsePolygon_properties").compare(type) == 0) {
      return new SWGGHIsochroneResponsePolygon_properties();
    }
    if(QString("SWGGHMatrixRequest").compare(type) == 0) {
      return new SWGGHMatrixRequest();
    }
    if(QString("SWGGHMatrixResponse").compare(type) == 0) {
      return new SWGGHMatrixResponse();
    }
    if(QString("SWGGHResponseCoordinates").compare(type) == 0) {
      return new SWGGHResponseCoordinates();
    }
    if(QString("SWGGHResponseCoordinatesArray").compare(type) == 0) {
      return new SWGGHResponseCoordinatesArray();
    }
    if(QString("SWGGHResponseInfo").compare(type) == 0) {
      return new SWGGHResponseInfo();
    }
    if(QString("SWGGHResponseInstruction").compare(type) == 0) {
      return new SWGGHResponseInstruction();
    }
    if(QString("SWGGHResponseInstructions").compare(type) == 0) {
      return new SWGGHResponseInstructions();
    }
    if(QString("SWGGHRouteResponse").compare(type) == 0) {
      return new SWGGHRouteResponse();
    }
    if(QString("SWGGHRouteResponsePath").compare(type) == 0) {
      return new SWGGHRouteResponsePath();
    }
    if(QString("SWGJobId").compare(type) == 0) {
      return new SWGJobId();
    }
    if(QString("SWGObjective").compare(type) == 0) {
      return new SWGObjective();
    }
    if(QString("SWGRelation").compare(type) == 0) {
      return new SWGRelation();
    }
    if(QString("SWGRequest").compare(type) == 0) {
      return new SWGRequest();
    }
    if(QString("SWGResponse").compare(type) == 0) {
      return new SWGResponse();
    }
    if(QString("SWGRoute").compare(type) == 0) {
      return new SWGRoute();
    }
    if(QString("SWGService").compare(type) == 0) {
      return new SWGService();
    }
    if(QString("SWGShipment").compare(type) == 0) {
      return new SWGShipment();
    }
    if(QString("SWGSolution").compare(type) == 0) {
      return new SWGSolution();
    }
    if(QString("SWGSolution_unassigned").compare(type) == 0) {
      return new SWGSolution_unassigned();
    }
    if(QString("SWGStop").compare(type) == 0) {
      return new SWGStop();
    }
    if(QString("SWGTimeWindow").compare(type) == 0) {
      return new SWGTimeWindow();
    }
    if(QString("SWGVehicle").compare(type) == 0) {
      return new SWGVehicle();
    }
    if(QString("SWGVehicleType").compare(type) == 0) {
      return new SWGVehicleType();
    }
    
    return nullptr;
  }

  inline void* create(QString json, QString type) {
    void* val = create(type);
    if(val != nullptr) {
      SWGObject* obj = static_cast<SWGObject*>(val);
      return obj->fromJson(json);
    }
    if(type.startsWith("QString")) {
      return new QString();
    }
    return nullptr;
  }
} /* namespace Swagger */

#endif /* ModelFactory_H_ */
