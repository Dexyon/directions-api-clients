/**
 * GraphHopper Directions API
 * You use the GraphHopper Directions API to add route planning, navigation and route optimization to your software. E.g. the Routing API has turn instructions and elevation data and the Route Optimization API solves your logistic problems and supports various constraints like time window and capacity restrictions. Also it is possible to get all distances between all locations with our fast Matrix API.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#ifndef ModelFactory_H_
#define ModelFactory_H_


#include "SWGActivity.h"
#include "SWGAddress.h"
#include "SWGAlgorithm.h"
#include "SWGBreak.h"
#include "SWGConfiguration.h"
#include "SWGCostMatrix.h"
#include "SWGCostMatrix_data.h"
#include "SWGCostMatrix_data_info.h"
#include "SWGGHError.h"
#include "SWGGHError_hints.h"
#include "SWGGHGeocodingLocation.h"
#include "SWGGHGeocodingPoint.h"
#include "SWGGHGeocodingResponse.h"
#include "SWGGHIsochroneResponse.h"
#include "SWGGHIsochroneResponsePolygon.h"
#include "SWGGHIsochroneResponsePolygon_geometry.h"
#include "SWGGHIsochroneResponsePolygon_properties.h"
#include "SWGGHMatrixRequest.h"
#include "SWGGHMatrixResponse.h"
#include "SWGGHResponseCoordinates.h"
#include "SWGGHResponseCoordinatesArray.h"
#include "SWGGHResponseInfo.h"
#include "SWGGHResponseInstruction.h"
#include "SWGGHResponseInstructions.h"
#include "SWGGHRouteResponse.h"
#include "SWGGHRouteResponsePath.h"
#include "SWGJobId.h"
#include "SWGLocation.h"
#include "SWGObjective.h"
#include "SWGRelation.h"
#include "SWGRequest.h"
#include "SWGResponse.h"
#include "SWGRoute.h"
#include "SWGRouting.h"
#include "SWGService.h"
#include "SWGShipment.h"
#include "SWGSolution.h"
#include "SWGSolution_unassigned.h"
#include "SWGStop.h"
#include "SWGTimeWindow.h"
#include "SWGVehicle.h"
#include "SWGVehicleType.h"

namespace Swagger {
  inline void* create(QString type) {
    if(QString("SWGActivity").compare(type) == 0) {
      return new SWGActivity();
    }
    if(QString("SWGAddress").compare(type) == 0) {
      return new SWGAddress();
    }
    if(QString("SWGAlgorithm").compare(type) == 0) {
      return new SWGAlgorithm();
    }
    if(QString("SWGBreak").compare(type) == 0) {
      return new SWGBreak();
    }
    if(QString("SWGConfiguration").compare(type) == 0) {
      return new SWGConfiguration();
    }
    if(QString("SWGCostMatrix").compare(type) == 0) {
      return new SWGCostMatrix();
    }
    if(QString("SWGCostMatrix_data").compare(type) == 0) {
      return new SWGCostMatrix_data();
    }
    if(QString("SWGCostMatrix_data_info").compare(type) == 0) {
      return new SWGCostMatrix_data_info();
    }
    if(QString("SWGGHError").compare(type) == 0) {
      return new SWGGHError();
    }
    if(QString("SWGGHError_hints").compare(type) == 0) {
      return new SWGGHError_hints();
    }
    if(QString("SWGGHGeocodingLocation").compare(type) == 0) {
      return new SWGGHGeocodingLocation();
    }
    if(QString("SWGGHGeocodingPoint").compare(type) == 0) {
      return new SWGGHGeocodingPoint();
    }
    if(QString("SWGGHGeocodingResponse").compare(type) == 0) {
      return new SWGGHGeocodingResponse();
    }
    if(QString("SWGGHIsochroneResponse").compare(type) == 0) {
      return new SWGGHIsochroneResponse();
    }
    if(QString("SWGGHIsochroneResponsePolygon").compare(type) == 0) {
      return new SWGGHIsochroneResponsePolygon();
    }
    if(QString("SWGGHIsochroneResponsePolygon_geometry").compare(type) == 0) {
      return new SWGGHIsochroneResponsePolygon_geometry();
    }
    if(QString("SWGGHIsochroneResponsePolygon_properties").compare(type) == 0) {
      return new SWGGHIsochroneResponsePolygon_properties();
    }
    if(QString("SWGGHMatrixRequest").compare(type) == 0) {
      return new SWGGHMatrixRequest();
    }
    if(QString("SWGGHMatrixResponse").compare(type) == 0) {
      return new SWGGHMatrixResponse();
    }
    if(QString("SWGGHResponseCoordinates").compare(type) == 0) {
      return new SWGGHResponseCoordinates();
    }
    if(QString("SWGGHResponseCoordinatesArray").compare(type) == 0) {
      return new SWGGHResponseCoordinatesArray();
    }
    if(QString("SWGGHResponseInfo").compare(type) == 0) {
      return new SWGGHResponseInfo();
    }
    if(QString("SWGGHResponseInstruction").compare(type) == 0) {
      return new SWGGHResponseInstruction();
    }
    if(QString("SWGGHResponseInstructions").compare(type) == 0) {
      return new SWGGHResponseInstructions();
    }
    if(QString("SWGGHRouteResponse").compare(type) == 0) {
      return new SWGGHRouteResponse();
    }
    if(QString("SWGGHRouteResponsePath").compare(type) == 0) {
      return new SWGGHRouteResponsePath();
    }
    if(QString("SWGJobId").compare(type) == 0) {
      return new SWGJobId();
    }
    if(QString("SWGLocation").compare(type) == 0) {
      return new SWGLocation();
    }
    if(QString("SWGObjective").compare(type) == 0) {
      return new SWGObjective();
    }
    if(QString("SWGRelation").compare(type) == 0) {
      return new SWGRelation();
    }
    if(QString("SWGRequest").compare(type) == 0) {
      return new SWGRequest();
    }
    if(QString("SWGResponse").compare(type) == 0) {
      return new SWGResponse();
    }
    if(QString("SWGRoute").compare(type) == 0) {
      return new SWGRoute();
    }
    if(QString("SWGRouting").compare(type) == 0) {
      return new SWGRouting();
    }
    if(QString("SWGService").compare(type) == 0) {
      return new SWGService();
    }
    if(QString("SWGShipment").compare(type) == 0) {
      return new SWGShipment();
    }
    if(QString("SWGSolution").compare(type) == 0) {
      return new SWGSolution();
    }
    if(QString("SWGSolution_unassigned").compare(type) == 0) {
      return new SWGSolution_unassigned();
    }
    if(QString("SWGStop").compare(type) == 0) {
      return new SWGStop();
    }
    if(QString("SWGTimeWindow").compare(type) == 0) {
      return new SWGTimeWindow();
    }
    if(QString("SWGVehicle").compare(type) == 0) {
      return new SWGVehicle();
    }
    if(QString("SWGVehicleType").compare(type) == 0) {
      return new SWGVehicleType();
    }
    
    return nullptr;
  }

  inline void* create(QString json, QString type) {
    void* val = create(type);
    if(val != nullptr) {
      SWGObject* obj = static_cast<SWGObject*>(val);
      return obj->fromJson(json);
    }
    if(type.startsWith("QString")) {
      return new QString();
    }
    return nullptr;
  }
} /* namespace Swagger */

#endif /* ModelFactory_H_ */
