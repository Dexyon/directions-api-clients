/**
 * GraphHopper Directions API
 * You use the GraphHopper Directions API to add route planning, navigation and route optimization to your software. E.g. the Routing API has turn instructions and elevation data and the Route Optimization API solves your logistic problems and supports various constraints like time window and capacity restrictions. Also it is possible to get all distances between all locations with our fast Matrix API.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef ModelFactory_H_
#define ModelFactory_H_

#include "OAIObject.h"

#include "OAIActivity.h"
#include "OAIAddress.h"
#include "OAIAlgorithm.h"
#include "OAIBreak.h"
#include "OAIConfiguration.h"
#include "OAICostMatrix.h"
#include "OAIDetail.h"
#include "OAIGHError.h"
#include "OAIGeocodingLocation.h"
#include "OAIGeocodingPoint.h"
#include "OAIGeocodingResponse.h"
#include "OAIIsochroneResponse.h"
#include "OAIIsochroneResponsePolygon.h"
#include "OAIJobId.h"
#include "OAILocation.h"
#include "OAIMatrixRequest.h"
#include "OAIMatrixResponse.h"
#include "OAIObjective.h"
#include "OAIRelation.h"
#include "OAIRequest.h"
#include "OAIResponse.h"
#include "OAIResponseCoordinates.h"
#include "OAIResponseCoordinatesArray.h"
#include "OAIResponseInfo.h"
#include "OAIResponseInstruction.h"
#include "OAIResponseInstructions.h"
#include "OAIRoute.h"
#include "OAIRoutePoint.h"
#include "OAIRouteResponse.h"
#include "OAIRouteResponsePath.h"
#include "OAIRouting.h"
#include "OAIService.h"
#include "OAIShipment.h"
#include "OAISolution.h"
#include "OAIStop.h"
#include "OAITimeWindow.h"
#include "OAIVehicle.h"
#include "OAIVehicleType.h"

namespace OpenAPI {

  inline void* create(QString type) {
    if(QString("OAIActivity").compare(type) == 0) {
      return new OAIActivity();
    }
    if(QString("OAIAddress").compare(type) == 0) {
      return new OAIAddress();
    }
    if(QString("OAIAlgorithm").compare(type) == 0) {
      return new OAIAlgorithm();
    }
    if(QString("OAIBreak").compare(type) == 0) {
      return new OAIBreak();
    }
    if(QString("OAIConfiguration").compare(type) == 0) {
      return new OAIConfiguration();
    }
    if(QString("OAICostMatrix").compare(type) == 0) {
      return new OAICostMatrix();
    }
    if(QString("OAIDetail").compare(type) == 0) {
      return new OAIDetail();
    }
    if(QString("OAIGHError").compare(type) == 0) {
      return new OAIGHError();
    }
    if(QString("OAIGeocodingLocation").compare(type) == 0) {
      return new OAIGeocodingLocation();
    }
    if(QString("OAIGeocodingPoint").compare(type) == 0) {
      return new OAIGeocodingPoint();
    }
    if(QString("OAIGeocodingResponse").compare(type) == 0) {
      return new OAIGeocodingResponse();
    }
    if(QString("OAIIsochroneResponse").compare(type) == 0) {
      return new OAIIsochroneResponse();
    }
    if(QString("OAIIsochroneResponsePolygon").compare(type) == 0) {
      return new OAIIsochroneResponsePolygon();
    }
    if(QString("OAIJobId").compare(type) == 0) {
      return new OAIJobId();
    }
    if(QString("OAILocation").compare(type) == 0) {
      return new OAILocation();
    }
    if(QString("OAIMatrixRequest").compare(type) == 0) {
      return new OAIMatrixRequest();
    }
    if(QString("OAIMatrixResponse").compare(type) == 0) {
      return new OAIMatrixResponse();
    }
    if(QString("OAIObjective").compare(type) == 0) {
      return new OAIObjective();
    }
    if(QString("OAIRelation").compare(type) == 0) {
      return new OAIRelation();
    }
    if(QString("OAIRequest").compare(type) == 0) {
      return new OAIRequest();
    }
    if(QString("OAIResponse").compare(type) == 0) {
      return new OAIResponse();
    }
    if(QString("OAIResponseCoordinates").compare(type) == 0) {
      return new OAIResponseCoordinates();
    }
    if(QString("OAIResponseCoordinatesArray").compare(type) == 0) {
      return new OAIResponseCoordinatesArray();
    }
    if(QString("OAIResponseInfo").compare(type) == 0) {
      return new OAIResponseInfo();
    }
    if(QString("OAIResponseInstruction").compare(type) == 0) {
      return new OAIResponseInstruction();
    }
    if(QString("OAIResponseInstructions").compare(type) == 0) {
      return new OAIResponseInstructions();
    }
    if(QString("OAIRoute").compare(type) == 0) {
      return new OAIRoute();
    }
    if(QString("OAIRoutePoint").compare(type) == 0) {
      return new OAIRoutePoint();
    }
    if(QString("OAIRouteResponse").compare(type) == 0) {
      return new OAIRouteResponse();
    }
    if(QString("OAIRouteResponsePath").compare(type) == 0) {
      return new OAIRouteResponsePath();
    }
    if(QString("OAIRouting").compare(type) == 0) {
      return new OAIRouting();
    }
    if(QString("OAIService").compare(type) == 0) {
      return new OAIService();
    }
    if(QString("OAIShipment").compare(type) == 0) {
      return new OAIShipment();
    }
    if(QString("OAISolution").compare(type) == 0) {
      return new OAISolution();
    }
    if(QString("OAIStop").compare(type) == 0) {
      return new OAIStop();
    }
    if(QString("OAITimeWindow").compare(type) == 0) {
      return new OAITimeWindow();
    }
    if(QString("OAIVehicle").compare(type) == 0) {
      return new OAIVehicle();
    }
    if(QString("OAIVehicleType").compare(type) == 0) {
      return new OAIVehicleType();
    }
    
    return nullptr;
  }

  inline void* create(QString json, QString type) {
    if(type.startsWith("QString")) {
      return new QString();
    }    
    auto val = static_cast<OAIObject*>(create(type));
    if(val != nullptr) {
      return val->fromJson(json);
    }
    return nullptr;
  }

}

#endif /* ModelFactory_H_ */
