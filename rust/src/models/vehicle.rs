/* 
 * GraphHopper Directions API
 *
 * You use the GraphHopper Directions API to add route planning, navigation and route optimization to your software. E.g. the Routing API has turn instructions and elevation data and the Route Optimization API solves your logistic problems and supports various constraints like time window and capacity restrictions. Also it is possible to get all distances between all locations with our fast Matrix API.
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Vehicle {
  /// Unique identifier of vehicle
  #[serde(rename = "vehicle_id")]
  vehicle_id: Option<String>,
  /// Unique identifier referring to the available vehicle types
  #[serde(rename = "type_id")]
  type_id: Option<String>,
  #[serde(rename = "start_address")]
  start_address: Option<::models::Address>,
  #[serde(rename = "end_address")]
  end_address: Option<::models::Address>,
  #[serde(rename = "break")]
  _break: Option<::models::ModelBreak>,
  /// Indicates whether vehicle should return to start address or not. If not, it can end at any service activity.
  #[serde(rename = "return_to_depot")]
  return_to_depot: Option<bool>,
  /// earliest start of vehicle at its start location
  #[serde(rename = "earliest_start")]
  earliest_start: Option<i64>,
  /// latest end of vehicle at its end location
  #[serde(rename = "latest_end")]
  latest_end: Option<i64>,
  /// array of skills
  #[serde(rename = "skills")]
  skills: Option<Vec<String>>,
  /// max distance of vehicle
  #[serde(rename = "max_distance")]
  max_distance: Option<i64>,
  /// max drive time of vehicle
  #[serde(rename = "max_driving_time")]
  max_driving_time: Option<i64>,
  /// max number of jobs the vehicle can load
  #[serde(rename = "max_jobs")]
  max_jobs: Option<i32>,
  /// max number of activities the vehicle can conduct
  #[serde(rename = "max_activities")]
  max_activities: Option<i32>
}

impl Vehicle {
  pub fn new() -> Vehicle {
    Vehicle {
      vehicle_id: None,
      type_id: None,
      start_address: None,
      end_address: None,
      _break: None,
      return_to_depot: None,
      earliest_start: None,
      latest_end: None,
      skills: None,
      max_distance: None,
      max_driving_time: None,
      max_jobs: None,
      max_activities: None
    }
  }

  pub fn set_vehicle_id(&mut self, vehicle_id: String) {
    self.vehicle_id = Some(vehicle_id);
  }

  pub fn with_vehicle_id(mut self, vehicle_id: String) -> Vehicle {
    self.vehicle_id = Some(vehicle_id);
    self
  }

  pub fn vehicle_id(&self) -> Option<&String> {
    self.vehicle_id.as_ref()
  }

  pub fn reset_vehicle_id(&mut self) {
    self.vehicle_id = None;
  }

  pub fn set_type_id(&mut self, type_id: String) {
    self.type_id = Some(type_id);
  }

  pub fn with_type_id(mut self, type_id: String) -> Vehicle {
    self.type_id = Some(type_id);
    self
  }

  pub fn type_id(&self) -> Option<&String> {
    self.type_id.as_ref()
  }

  pub fn reset_type_id(&mut self) {
    self.type_id = None;
  }

  pub fn set_start_address(&mut self, start_address: ::models::Address) {
    self.start_address = Some(start_address);
  }

  pub fn with_start_address(mut self, start_address: ::models::Address) -> Vehicle {
    self.start_address = Some(start_address);
    self
  }

  pub fn start_address(&self) -> Option<&::models::Address> {
    self.start_address.as_ref()
  }

  pub fn reset_start_address(&mut self) {
    self.start_address = None;
  }

  pub fn set_end_address(&mut self, end_address: ::models::Address) {
    self.end_address = Some(end_address);
  }

  pub fn with_end_address(mut self, end_address: ::models::Address) -> Vehicle {
    self.end_address = Some(end_address);
    self
  }

  pub fn end_address(&self) -> Option<&::models::Address> {
    self.end_address.as_ref()
  }

  pub fn reset_end_address(&mut self) {
    self.end_address = None;
  }

  pub fn set__break(&mut self, _break: ::models::ModelBreak) {
    self._break = Some(_break);
  }

  pub fn with__break(mut self, _break: ::models::ModelBreak) -> Vehicle {
    self._break = Some(_break);
    self
  }

  pub fn _break(&self) -> Option<&::models::ModelBreak> {
    self._break.as_ref()
  }

  pub fn reset__break(&mut self) {
    self._break = None;
  }

  pub fn set_return_to_depot(&mut self, return_to_depot: bool) {
    self.return_to_depot = Some(return_to_depot);
  }

  pub fn with_return_to_depot(mut self, return_to_depot: bool) -> Vehicle {
    self.return_to_depot = Some(return_to_depot);
    self
  }

  pub fn return_to_depot(&self) -> Option<&bool> {
    self.return_to_depot.as_ref()
  }

  pub fn reset_return_to_depot(&mut self) {
    self.return_to_depot = None;
  }

  pub fn set_earliest_start(&mut self, earliest_start: i64) {
    self.earliest_start = Some(earliest_start);
  }

  pub fn with_earliest_start(mut self, earliest_start: i64) -> Vehicle {
    self.earliest_start = Some(earliest_start);
    self
  }

  pub fn earliest_start(&self) -> Option<&i64> {
    self.earliest_start.as_ref()
  }

  pub fn reset_earliest_start(&mut self) {
    self.earliest_start = None;
  }

  pub fn set_latest_end(&mut self, latest_end: i64) {
    self.latest_end = Some(latest_end);
  }

  pub fn with_latest_end(mut self, latest_end: i64) -> Vehicle {
    self.latest_end = Some(latest_end);
    self
  }

  pub fn latest_end(&self) -> Option<&i64> {
    self.latest_end.as_ref()
  }

  pub fn reset_latest_end(&mut self) {
    self.latest_end = None;
  }

  pub fn set_skills(&mut self, skills: Vec<String>) {
    self.skills = Some(skills);
  }

  pub fn with_skills(mut self, skills: Vec<String>) -> Vehicle {
    self.skills = Some(skills);
    self
  }

  pub fn skills(&self) -> Option<&Vec<String>> {
    self.skills.as_ref()
  }

  pub fn reset_skills(&mut self) {
    self.skills = None;
  }

  pub fn set_max_distance(&mut self, max_distance: i64) {
    self.max_distance = Some(max_distance);
  }

  pub fn with_max_distance(mut self, max_distance: i64) -> Vehicle {
    self.max_distance = Some(max_distance);
    self
  }

  pub fn max_distance(&self) -> Option<&i64> {
    self.max_distance.as_ref()
  }

  pub fn reset_max_distance(&mut self) {
    self.max_distance = None;
  }

  pub fn set_max_driving_time(&mut self, max_driving_time: i64) {
    self.max_driving_time = Some(max_driving_time);
  }

  pub fn with_max_driving_time(mut self, max_driving_time: i64) -> Vehicle {
    self.max_driving_time = Some(max_driving_time);
    self
  }

  pub fn max_driving_time(&self) -> Option<&i64> {
    self.max_driving_time.as_ref()
  }

  pub fn reset_max_driving_time(&mut self) {
    self.max_driving_time = None;
  }

  pub fn set_max_jobs(&mut self, max_jobs: i32) {
    self.max_jobs = Some(max_jobs);
  }

  pub fn with_max_jobs(mut self, max_jobs: i32) -> Vehicle {
    self.max_jobs = Some(max_jobs);
    self
  }

  pub fn max_jobs(&self) -> Option<&i32> {
    self.max_jobs.as_ref()
  }

  pub fn reset_max_jobs(&mut self) {
    self.max_jobs = None;
  }

  pub fn set_max_activities(&mut self, max_activities: i32) {
    self.max_activities = Some(max_activities);
  }

  pub fn with_max_activities(mut self, max_activities: i32) -> Vehicle {
    self.max_activities = Some(max_activities);
    self
  }

  pub fn max_activities(&self) -> Option<&i32> {
    self.max_activities.as_ref()
  }

  pub fn reset_max_activities(&mut self) {
    self.max_activities = None;
  }

}



